# Individual Classes and Functions 


# First Class: Compatible Parent Genotypes  

class SufficientStat:
    def compatible_mating_haplotypes(self):
        if self.nMarkers == 0:
            return None

        cpg = [None] * self.nMarkers
        for i in range(self.nMarkers):
            cpg[i] = self.enumerate_compatible_mating_genotype(i)

        if self.nMarkers == 1:
            cmh = None
            for i in range(cpg[0].ngt):
                cmh = MatingHaplotype(self.nMarkers, None, None, cmh)
                cmh.h[0][0] = cpg[0].gt[i][0].a[0]
                cmh.h[1][0] = 0 if self.xlink else cpg[0].gt[i][0].a[1]
                cmh.h[2][0] = cpg[0].gt[i][1].a[0]
                cmh.h[3][0] = cpg[0].gt[i][1].a[1]
                cmh.hash_val = cmh.hash()
            for i in range(self.nMarkers):
                if cpg[i]:
                    del cpg[i]
            del cpg
            return cmh

        iteration_counter = 0
        cmh = None
        cmh_last_node = None
        ncmh = 0

        if all(cpg[i].ngt > 0 for i in range(self.nMarkers)):
            idx = [0] * self.nMarkers
            while idx[0] < cpg[0].ngt:
                pg = [None] * 2
                for i in range(2):
                    pg[i] = [None] * self.nMarkers
                    for j in range(self.nMarkers):
                        pg[i][j] = cpg[j].gt[idx[j]][i]

                mh = MatingMmGenotype(self.nMarkers, pg, self.xlink)
                if self.xlink:
                    resolved = mh.resolve_x(self.n_offspring, self.ogt, self.sex)
                else:
                    resolved = mh.resolve(self.n_offspring, self.ogt)

                if resolved:
                    if cmh is None:
                        cmh = mh.enumerate_mating_haplo(self.n_offspring, self.ogt, self.sex, 2 * self.maxcmh)
                        if cmh is not None:
                            ncmh = 1
                            cmh_last_node = cmh
                            while cmh_last_node.next is not None:
                                cmh_last_node = cmh_last_node.next
                                ncmh += 1
                    else:
                        cmh_last_node.next = mh.enumerate_mating_haplo(self.n_offspring, self.ogt, self.sex, self.maxcmh)
                        while cmh_last_node.next is not None:
                            cmh_last_node = cmh_last_node.next
                            ncmh += 1

                if mh is not None:
                    del mh

                if self.maxcmh != 0 and ncmh > 2 * self.maxcmh:
                    break

                j = self.nMarkers - 1
                while j >= 0 and idx[j] + 1 == cpg[j].ngt:
                    idx[j] = 0
                    j -= 1
                if j < 0:
                    break
                idx[j] += 1

                iteration_counter += 1
                if iteration_counter == 1000000 and ncmh == 0:
                    break

            del idx

        return cmh






# Second Class: Haploid



class HaploidTable:
    def maketable(self, hl):
        minp = 0.0001

        if hl is None:
            return

        hl2 = hl
        size = 0
        while hl2 is not None:
            if hl2.p >= minp:
                for i in range(2):
                    if hl2.h[i][0] > 0:  # not missing as in male x-linked markers
                        hld = self.find(hl2.h[i])
                        if hld is None:
                            if self.hpl is None:
                                self.hpl = HaploidList(Haploid(hl2.nmrk, hl2.h[i], hl2.p / 2), self.hpl)
                            else:
                                HaploidList(Haploid(hl2.nmrk, hl2.h[i], hl2.p / 2), self.hpl)
                            size += 1
                        else:
                            hld.p += hl2.p / 2
            hl2 = hl2.next








# Third class Haplotype List
class HaplotypeList:
    def __init__(self, n, h1=None, h2=None, nxt=None):
        self.h = [None] * 2
        for i in range(2):
            self.h[i] = [0] * n
        
        if h1 is not None and h2 is not None:
            for i in range(n):
                self.h[0][i] = h1[i]
                self.h[1][i] = h2[i]

        self.nmrk = n
        self.next = nxt
        self.p = 0.0
        self.q = 0.0

    def equal(self, h1, h2):
        for i in range(self.nmrk):
            if not (self.h[0][i] == h1[i] and self.h[1][i] == h2[i]):
                break
        else:
            return True

        for i in range(self.nmrk):
            if not (self.h[0][i] == h2[i] and self.h[1][i] == h1[i]):
                break
        else:
            return True
        
        return False

    def find(self, h1, h2):
        hl = self
        while hl is not None and not hl.equal(h1, h2):
            hl = hl.next
        return hl

    def __del__(self):
        for i in range(2):
            if self.h[i] is not None:
                del self.h[i]
        
        if self.next is not None:
            del self.next




# Class defining Mating Haplotype 
class MatingHaplotype:
    def __init__(self, n, h1=None, h2=None, nxt=None):
        self.nmrks = n
        self.h = [bytearray(n) for _ in range(4)]
        
        for j in range(2):
            for i in range(n):
                self.h[j][i] = h1.h[j][i] if h1 else 0
                self.h[j + 2][i] = h2.h[j][i] if h2 else 0

        self.hash_val = self.hash() if h1 and h2 else 0
        self.pg = [0.0] * 4
        self.pset = 0.0
        self.frq = 0.0
        self.hl = [None, None]
        self.next = nxt

    def hash(self):
        a = [0] * 4

        for i in range(4):
            for j in range(self.nmrks):
                k = self.h[i][j]
                a[i] ^= (k << (j & 8))
            a[i] &= 255

        i = min(a[0], a[1])
        j = min(a[2], a[3])
        if i < j or (i == j and a[0] + a[1] < a[2] + a[3]):
            k = i + ((a[0] + a[1] - i) << 8) + (j << 16) + ((a[2] + a[3] - j) << 24)
        else:
            k = j + ((a[2] + a[3] - j) << 8) + (i << 16) + ((a[0] + a[1] - i) << 24)

        return k

    def len(self):
        i = 0
        mh = self.next
        while mh:
            i += 1
            mh = mh.next

        return i + 1

    def equal(self, mh):
        if mh.hash_val != self.hash_val:
            return False

        conditions = [
            (self.h[0] == mh.h[0] and self.h[1] == mh.h[1]) or
            (self.h[0] == mh.h[1] and self.h[1] == mh.h[0]),
            
            (self.h[2] == mh.h[2] and self.h[3] == mh.h[3]) or
            (self.h[2] == mh.h[3] and self.h[3] == mh.h[2]),
            
            (self.h[0] == mh.h[2] and self.h[1] == mh.h[3]) or
            (self.h[0] == mh.h[3] and self.h[1] == mh.h[2]),
            
            (self.h[2] == mh.h[0] and self.h[3] == mh.h[1]) or
            (self.h[2] == mh.h[1] and self.h[3] == mh.h[0])
        ]

        return all(conditions[:2]) or all(conditions[2:])

    def n_heterozygotes(self):
        n = 0
        for i in range(0, 3, 2):
            j = 0
            while j < self.nmrks and self.h[i][j] == self.h[i + 1][j]:
                j += 1
            if j == self.nmrks:
                n += 1

        return 2 - n

    def __del__(self):
        del self.h
        if self.next:
            del self.next

    def gt_compatible(self, g):
        for i in range(2):
            for j in range(2, 4):
                k = 0
                while k < self.nmrks and (g[k].a[0] == 0 or g[k].equal(self.h[i][k], self.h[j][k])):
                    k += 1
                if k == self.nmrks:
                    return True
        return False

    def unique(self, idx):
        j = 0
        while j < self.nmrks and self.h[idx * 2][j] != kotherallele and self.h[idx * 2 + 1][j] != kotherallele:
            j += 1

        return j == self.nmrks

    def get_p_set(self, cnt, is_observed):
        p = 1.0
        for i in range(4):
            if cnt[i] > 0:
                p *= self.pg[i] ** cnt[i]

        if is_observed:
            self.pset = p

        return p






# Class defining 
